---
title: 'roo-logger: Cline Memory Bank とは違うAIの記憶システムを（MCPで）作った理由'
emoji: '📝'
type: 'tech'
topics:
  - AI
  - MCP
  - Cline
  - Roo Code
published: false
---

[roo-logger](https://github.com/annenpolka/roo-logger)という MCP サーバーを作ったので紹介します。これは[Cline Memory Bank](https://docs.cline.bot/improving-your-prompting-skills/cline-memory-bank)とは違ったアプローチで AI の記憶を管理するツールです。

最近、AI との協業どころか vibe coding で全て書かせてしまおうなんて話もある中で、「AI が何をしたか覚えていない問題」が顕在化してきました。特に Roo Code のような自律型エージェントが大量のファイル操作やコマンド実行をする場合、同じセッションを使い続けることはコンテキスト長的に不可能です。

そして、Memory Bank はプロジェクトの知識を構造化するのに素晴らしいシステムですが、「AI がどうして何をしたのか」の詳細な記録には向いていないと感じました。

セッションが違えば AI が一貫した方向性で編集してくれるかは運試しになりやすく（特に Roo-Code の boomerang task 機能を使う時など）、大抵の場合（vibe coding の元来の意図には反して）AI の行動に細かくフィードバックを与えたりする（それを覚えて・思い出していてほしい）ので、行動単位の記録が必要だなと考えました。

そこで Memory Bank とは異なるアプローチを考え、AI の行動履歴に特化した roo-logger を開発しました。

## Memory Bank の限界と roo-logger の誕生

Memory Bank をしばらく使ってみて気づいた課題をまとめてみます：

| 課題                                 | 詳細                                                               |
| ------------------------------------ | ------------------------------------------------------------------ |
| **行動の細かい履歴には向いていない** | 「ファイル X の Y 行目を編集した」みたいな操作履歴を残すのは難しい |
| **更新が手動または明示的**           | AI の活動はリアルタイムに記録されない                              |
| **階層的な関係性を表現しにくい**     | 「タスク A のサブタスク B」という親子関係を表現する仕組みがない    |
| **Markdown は人間向けの形式**        | 人間が読みやすいけど、AI が検索するには構造化が足りない            |

これらの課題を解決するために、AI の行動履歴に特化したロガーを作ることにしました。JSON 形式で構造化し、AI から直接呼び出せる MCP サーバーとして実装することで、AI が自分の活動履歴を自動的に記録し、後から検索できるようにしています。

## roo-logger の基本設計

roo-logger の基本設計は、「何をしたか」「なぜそうしたのか」「どう関連しているのか」を構造化して記録することです。ログはこんな感じの JSON 形式で保存されます：

```json
{
  "id": "75add15d-8d5b-4e60-b327-fde785050c86",
  "timestamp": "2025-04-10T01:58:02.905Z",
  "type": "file_operation",
  "level": "info",
  "summary": "README.mdにmermaid図を挿入完了",
  "details": {
    "file": "README.md",
    "operation": "insert_content",
    "insertedLines": "mermaidコードブロック",
    "position": "概要セクション直後"
  },
  "intention": "アクティビティの保存と呼び出しの流れを視覚的に説明するため",
  "context": "Roo Activity Loggerの利用者理解促進のためのドキュメント改善作業",
  "parentId": "98280366-1de1-48e0-9914-b3a3409599b4"
}
```

特に重要なフィールドは以下の通りです：

- **type**: 活動の種類（command_execution, code_generation, file_operation 等）
- **intention**: なぜその活動を行ったのか
- **context**: どのような状況でその活動を行ったのか
- **parentId**: 親タスクの ID（階層関係を表現）

これらの情報があれば、AI は「自分が何をしたのか、なぜそうしたのか」を後から正確に思い出せるわけです。

### なぜ MCP というアプローチを選んだのか

「なぜプロンプトではなく MCP サーバーとして実装したのか？」という疑問があるかもしれません。これには明確な理由があります。

1. 構造化した出力を強制したかった
   - Structured Outputs のように、JSON スキーマに従った応答を確実に得たかった
   - AI が自由に書くと、ログの形式が不統一になり検索性が落ちる
2. AI から直接呼び出せる必要があった
   - Memory Bank はファイルとして存在し、AI がそれを「読む」
   - 対照的に、roo-logger は AI から「呼び出される」関数として存在する
   - この違いにより、AI は自分で記録・検索のタイミングを制御できる
3. 標準化されたインターフェースが欲しかった
   - MCP は AI モデルと外部ツールをつなぐ標準プロトコル
   - 一度 MCP として実装すれば、Roo Code 以外の AI ツールでも利用可能になる

MCP を選んだことで、AI による記録が一貫した形式で行われ、検索性の高いログデータが自動的に蓄積されていく。「AI に構造化された日記をつけさせる」ようなイメージでしょうか。

## Memory Bank と Roo Logger の比較

両者の違いを明確にするために、特徴を表にまとめてみました。

（Memory Bank はプロンプトの調整次第な部分もありますが、参考程度に）

| 特徴               | roo-logger              | Memory Bank                   |
| ------------------ | ----------------------- | ----------------------------- |
| **記録対象**       | AI の「行動履歴」       | プロジェクトの「知識」        |
| **記録形式**       | JSON (機械可読)         | Markdown (人間可読)           |
| **更新タイミング** | 活動ごとリアルタイム    | セッション終了時/手動         |
| **主な目的**       | AI の行動を追跡         | プロジェクト知識を構造化      |
| **ファイル構造**   | 日付ベースの自動生成    | 決められた 6 つの主要ファイル |
| **呼び出し方法**   | MCP ツールとして直接    | ファイル読み込みとして間接的  |
| **人間の関与**     | 最小限（AI が自動記録） | 大きい（人間も編集する）      |
| **適した保存内容** | 「〜をした」行動記録    | 「〜である」知識記録          |

私は両者を「**実験ノート**」と「**教科書**」の関係だと思っています。両方あれば、AI はプロジェクトについての知識と、自分がこれまでに行った実験（操作）の両方を思い出せます。

## セットアップ方法

roo-logger のセットアップは非常に簡単です。Roo Code の設定ファイルに以下を追加するだけです：

```json
{
  "mcpServers": {
    "roo-activity-logger": {
      "command": "npx",
      "args": ["-y", "github:annenpolka/roo-logger"],
      "env": {},
      "disabled": false
    }
  }
}
```

Roo Code では、`.roo/mcp.json` ファイルに上記の設定を追加します。

## AI への指示方法（プロンプト例）

（いずれの例もツールやモデルによって効き具合は変わってくるので、ご留意ください）

### roo-logger 単体で使う場合のプロンプト例

roo-logger を単体で使う場合は、以下のようなプロンプトがおすすめです。

```bash
## 活動記録に関する重要なルール

あなたは全ての重要な活動を記録するために roo-activity-logger のlog_activityを使用して`logs/`に記録してください。

### ログ記録のポイント

1. 以下の活動は必ず記録してください：
   - コマンド実行（command_execution）
   - コード生成（code_generation）
   - ファイル操作（file_operation）
   - エラー遭遇（error_encountered）
   - 重要な判断（decision_made）
   - 重要な会話（conversation）

2. 各活動記録には必ず以下の情報を含めてください：
   - 概要（何を行ったか）
   - 意図（なぜそれを行ったか）
   - 文脈（どのような状況でそれを行ったか）

3. タスクの階層構造を表現するために：
   - 大きなタスクを開始する際は、新しいログエントリを作成
   - サブタスクを実行する際は、親タスクのIDをparentIdとして設定

### セッション開始時

新しいセッションを開始する際は必ず以下を実行してください：

1. search_logs を使用して最近の活動履歴を取得
2. 前回のセッションでの作業内容を確認
3. 未完了のタスクがあれば、その続きから作業を開始
```

### Memory Bank との併用パターン

両方のシステムを併用する場合は、以下のようなプロンプトをお試しください。

```markdown
あなたはプロジェクト作業を進める際に、以下の 2 つの記憶システムを活用してください：

1. Memory Bank (知識の管理)

   - memory-bank/フォルダ内の Markdown ファイルを読んでプロジェクト知識を理解する
   - 重要な決定や知識を獲得したら、適切なファイルを更新する
   - 特に作業開始時は必ず Memory Bank の内容を確認する

2. roo-logger (行動履歴の記録)
   - すべての重要な操作（コード生成、ファイル操作、コマンド実行など）を log_activity で記録する
   - 必ず「intention」と「context」を含める
   - タスクが複数の小タスクに分かれる場合は、親子関係を parentId で表現する
   - 作業再開時には、search_logs で過去のログを検索して前回の状態を思い出す

これらの記憶システムは相補的な関係にあります。Memory Bank でプロジェクトの「大きな地図」を理解し、roo-logger で「具体的な作業履歴」を管理してください。
```

## MCP ツールの詳細

roo-logger は主に 3 つの MCP ツールを提供しています。それぞれの使い方と用途を解説します。

### 1. log_activity - 記憶を保存

AI が活動を記録するためのツール。以下のパラメータを受け取ります：

| パラメータ   | 必須 | 説明                                                                                                             |
| ------------ | ---- | ---------------------------------------------------------------------------------------------------------------- |
| `type`       | ✅   | 活動の種類（command_execution, code_generation, file_operation, error_encountered, decision_made, conversation） |
| `summary`    | ✅   | 活動の概要                                                                                                       |
| `intention`  | ✅   | なぜその活動を行ったか                                                                                           |
| `context`    | ✅   | どのような状況でその活動を行ったか                                                                               |
| `logsDir`    | ✅   | ログの保存先（絶対パス）                                                                                         |
| `level`      | ❌   | ログレベル（debug, info, warn, error）。デフォルト: info                                                         |
| `details`    | ❌   | 活動の詳細（任意の JSON オブジェクト）                                                                           |
| `parentId`   | ❌   | 親タスク ID（階層関係用）                                                                                        |
| `sequence`   | ❌   | シーケンス番号（順序関係用）                                                                                     |
| `relatedIds` | ❌   | 関連タスク ID 配列（関連性表現用）                                                                               |

### 2. search_logs - 記憶を検索

AI が過去の活動を検索するためのツール。以下のパラメータで検索が可能です：

| パラメータ                 | 説明                                        |
| -------------------------- | ------------------------------------------- |
| `logsDir`                  | **必須**: ログディレクトリ（絶対パス）      |
| `type`                     | 活動タイプでフィルタリング                  |
| `level`                    | ログレベルでフィルタリング                  |
| `startDate` / `endDate`    | 日付範囲でフィルタリング（YYYY-MM-DD 形式） |
| `searchText`               | テキスト検索                                |
| `parentId`                 | 親タスク ID で関連するサブタスクを検索      |
| `relatedId` / `relatedIds` | 関連タスクで検索                            |
| `limit`                    | 取得する最大ログ数（デフォルト: 50）        |
| `offset`                   | スキップするログ数（デフォルト: 0）         |

### 3. get_log_files - ログファイル一覧取得

ログディレクトリ内のファイル一覧を取得するためのシンプルなツール。

## 実践パターン

roo-logger の実践的な使い方として、特に効果的なパターンを紹介します。

### 階層的なタスク管理

Roo Code は複雑なタスクを複数のサブタスクに分解するのが得意です。roo-logger を使うと、こうした階層構造も記録できます。

Roo Code の「Boomerang Task」機能（タスクを複数のサブタスクに分解して処理する機能）と組み合わせると、各サブタスクがどのように親タスクに関連しているかを明確に記録でき、後から辿りやすくなります。

例えば、「ユーザー認証機能の実装」というタスクを以下のようなサブタスクに分解した場合：

1. ログインフォームのコンポーネント作成
2. 認証 API との連携実装
3. 状態管理の実装
4. テストコードの作成

これらの関係性を階層的に記録しておくことで、後から「なぜこのコードが生成されたのか」「どのタスクの一部だったのか」を追跡できます。

### セッション間の継続性確保

AI は通常、セッションが終わると文脈がリセットされます。しかし、roo-logger のログは永続的なので、次のセッションでも AI が前回の作業を思い出せます。

セッション開始時に AI に前回の作業を思い出させるには、以下のようなパターンが効果的です：

1. search_logs で最近の活動ログを取得
2. 未完了のタスクがあれば、その続きから作業を再開
3. 完了したタスクがあれば、次のタスクに進む

これにより、セッションをまたいでも一貫した作業が可能になります。

## roo-logger を作って気づいたこと

このツールを作って実際に使ってみて、いくつか面白い発見がありました：

### 1. AI の記憶には二重構造が効果的かも

roo-logger 単体で利用してもタスクの再開などスムーズになりますが、「知識」と「行動履歴」という二つの異なる記憶システムがあると、AI の作業能力が大きく向上することがわかりました。Memory Bank のような知識ベースと、roo-logger のような行動履歴を組み合わせることで、AI はより人間らしい記憶機能を獲得する…のかも。

これは人間の「宣言的記憶」（事実や概念の知識）と「エピソード記憶」（経験や出来事の記憶）に似ていると思いました。

### 2. 行動履歴の構造化が重要

単に「何をしたか」だけでなく「なぜそうしたのか」「どう関連しているのか」という情報が特に重要だとわかりました。意図や文脈、関連性の情報があることで、AI は過去の行動を単なるイベントリストではなく、意味のある「物語」として記憶できます。

### 3. AI の透明性向上

AI の判断や行動の理由が記録されることで、後からの検証や理解が容易になりました。これは AI の「説明可能性」を高める効果があります。特にチームで開発を行う場合、「AI がなぜその判断をしたのか」を追跡できることは重要になるはずです。

## まとめ

roo-logger は、Memory Bank を補完するための AI 記憶システムです。Memory Bank が「知識」を管理するのに対して、roo-logger は「行動履歴」を記録します。

### 重要ポイント

- AI が自分の行動と意図を構造化して記録できる
- JSON 形式で検索性が高い
- 階層関係を表現できる
- MCP プロトコルで AI から直接呼び出せる

両方のシステムを組み合わせることで、AI は「このプロジェクトは何か」と「今まで何をしてきたか」の両方を記憶でき、長期的なプロジェクトでも一貫した作業が可能になります。

AI との協業が進む中で、こうした記憶システムの重要性はますます高まるでしょう。特に複数の人間と AI が関わる大きなプロジェクトでは、AI の行動履歴を追跡することが不可欠になってくると思います。

Memory Bank のファイル構造はこれでいいとして、行動履歴の部分は roo-logger で補完する。そんなアプローチを試してみてほしいです。

<https://github.com/annenpolka/roo-logger>
